#if UNITY_5 || UNITY_5_3_OR_NEWER

using System.Collections;
using Svelto.DataStructures;
using Svelto.Tasks.Unity.Internal;
using UnityEngine;

#if TASKS_PROFILER_ENABLED
using Svelto.Tasks.Profiler;
#endif

namespace Svelto.Tasks.Unity
{
<<<<<<< .merge_file_a31668
    public abstract class MonoRunner<T> : IRunner<T> where T:IEnumerator
=======
    /// <summary>
    /// while you can instantiate a MonoRunner, you should use the standard one
    /// whenever possible. Instantiating multiple runners will defeat the
    /// initial purpose to get away from the Unity monobehaviours
    /// internal updates. MonoRunners are disposable though, so at
    /// least be sure to dispose of them once done
    /// </summary>

    public abstract class MonoRunner : IRunner
>>>>>>> .merge_file_a32168
    {
        public bool paused { set; get; }
        public bool isStopping { get { return _flushingOperation.stopped; } }
        public int  numberOfRunningTasks { get { return _coroutines.Count; } }
        
        public GameObject _go;

<<<<<<< .merge_file_a31668
        protected abstract UnityCoroutineRunner<T>.RunningTasksInfo info { get; }
        protected abstract ThreadSafeQueue<PausableTask<T>> newTaskRoutines { get; }
        protected abstract UnityCoroutineRunner<T>.FlushingOperation flushingOperation { get; }
        protected GameObject _go;
=======
        ~MonoRunner()
        {
            StopAllCoroutines();
        }
>>>>>>> .merge_file_a32168
        
        /// <summary>
        /// TaskRunner doesn't stop executing tasks between scenes
        /// it's the final user responsibility to stop the tasks if needed
        /// </summary>
        public virtual void StopAllCoroutines()
        {
            paused = false;

<<<<<<< .merge_file_a31668
            UnityCoroutineRunner<T>.StopRoutines(flushingOperation);

            newTaskRoutines.Clear();
        }

        public virtual void StartCoroutine(PausableTask<T> task)
        {
            paused = false;

            newTaskRoutines.Enqueue(task); //careful this could run on another thread!
        }

        public void Dispose()
=======
            UnityCoroutineRunner.StopRoutines(_flushingOperation);

            _newTaskRoutines.Clear();
        }

        public virtual void StartCoroutine(IPausableTask task)
        {
            paused = false;

            _newTaskRoutines.Enqueue(task); //careful this could run on another thread!
        }

        public virtual void Dispose()
>>>>>>> .merge_file_a32168
        {
            StopAllCoroutines();
            
            GameObject.DestroyImmediate(_go);
        }
        
        protected readonly ThreadSafeQueue<IPausableTask> _newTaskRoutines = new ThreadSafeQueue<IPausableTask>();
        protected readonly FasterList<IPausableTask> _coroutines =
            new FasterList<IPausableTask>(NUMBER_OF_INITIAL_COROUTINE);
        
        protected UnityCoroutineRunner.FlushingOperation _flushingOperation =
            new UnityCoroutineRunner.FlushingOperation();
        
        const int NUMBER_OF_INITIAL_COROUTINE = 3;
    }
}
#endif
